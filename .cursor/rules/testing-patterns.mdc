---
globs: src/**/*.test.*,src/**/*.spec.*
description: Testing patterns and best practices
---

# Testing Patterns

This project uses Jest and React Testing Library for comprehensive testing coverage:

## 🧪 Testing Structure

### **Test File Organization:**
```
src/
├── __tests__/
│   ├── unit/          # Unit tests
│   ├── integration/   # Integration tests
│   └── e2e/           # End-to-end tests
├── components/
│   └── Component.test.tsx
├── hooks/
│   └── useHook.test.ts
├── lib/
│   └── utils.test.ts
└── app/
    └── api/
        └── endpoint.test.ts
```

### **Test File Naming:**
```typescript
// Component tests
Component.test.tsx
Component.spec.tsx

// Hook tests
useCustomHook.test.ts

// Utility tests
utils.test.ts

// API tests
route.test.ts
```

## 🎯 Testing Patterns

### **Component Testing:**
```typescript
// Component.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { Component } from './Component'

describe('Component', () => {
  it('renders correctly', () => {
    render(<Component />)
    expect(screen.getByText('Expected text')).toBeInTheDocument()
  })

  it('handles user interactions', async () => {
    render(<Component />)

    const button = screen.getByRole('button', { name: /click me/i })
    fireEvent.click(button)

    await waitFor(() => {
      expect(screen.getByText('Updated text')).toBeInTheDocument()
    })
  })

  it('handles async operations', async () => {
    render(<Component />)

    await waitFor(() => {
      expect(screen.getByText('Loaded data')).toBeInTheDocument()
    }, { timeout: 3000 })
  })
})
```

### **Hook Testing:**
```typescript
// useCustomHook.test.ts
import { renderHook, act } from '@testing-library/react'
import { useCustomHook } from './useCustomHook'

describe('useCustomHook', () => {
  it('returns initial value', () => {
    const { result } = renderHook(() => useCustomHook('initial'))

    expect(result.current.value).toBe('initial')
  })

  it('updates value', () => {
    const { result } = renderHook(() => useCustomHook('initial'))

    act(() => {
      result.current.setValue('updated')
    })

    expect(result.current.value).toBe('updated')
  })

  it('handles async operations', async () => {
    const { result } = renderHook(() => useCustomHook())

    await act(async () => {
      await result.current.asyncOperation()
    })

    expect(result.current.data).toBeDefined()
  })
})
```

### **API Testing:**
```typescript
// route.test.ts
import { NextRequest } from 'next/server'
import { GET, POST } from './route'

describe('/api/resource', () => {
  it('returns 200 for GET request', async () => {
    const request = new NextRequest('http://localhost:3000/api/resource')
    const response = await GET(request)

    expect(response.status).toBe(200)
    const data = await response.json()
    expect(data.success).toBe(true)
  })

  it('creates resource with POST', async () => {
    const request = new NextRequest('http://localhost:3000/api/resource', {
      method: 'POST',
      body: JSON.stringify({ name: 'Test' }),
      headers: { 'content-type': 'application/json' }
    })

    const response = await POST(request)
    expect(response.status).toBe(201)

    const data = await response.json()
    expect(data.data.name).toBe('Test')
  })
})
```

## 🛠️ Testing Utilities

### **Custom Render Function:**
```typescript
// test-utils/render.tsx
import { render, RenderOptions } from '@testing-library/react'
import { ThemeProvider } from '@/components/theme-provider'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const createTestQueryClient = () =>
  new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  })

function customRender(
  ui: React.ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) {
  const queryClient = createTestQueryClient()

  const wrapper = ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>{children}</ThemeProvider>
    </QueryClientProvider>
  )

  return render(ui, { wrapper, ...options })
}

export * from '@testing-library/react'
export { customRender as render }
```

### **Mock Setup:**
```typescript
// __mocks__/api.ts
export const mockApi = {
  get: jest.fn(),
  post: jest.fn(),
  put: jest.fn(),
  delete: jest.fn()
}

jest.mock('@/lib/api', () => mockApi)
```

### **Test Data Factories:**
```typescript
// __mocks__/factories.ts
export const createMockUser = (overrides = {}) => ({
  id: 'user-1',
  name: 'John Doe',
  email: 'john@example.com',
  role: 'user',
  ...overrides
})

export const createMockProduct = (overrides = {}) => ({
  id: 'product-1',
  name: 'Test Product',
  price: 29.99,
  category: 'test',
  ...overrides
})
```

## 🔧 Test Configuration

### **Jest Config:**
```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
}
```

### **Setup File:**
```javascript
// jest.setup.js
import '@testing-library/jest-dom'

// Mock Next.js router
jest.mock('next/router', () => ({
  useRouter: () => ({
    push: jest.fn(),
    replace: jest.fn(),
    prefetch: jest.fn(),
    back: jest.fn(),
    pathname: '/',
    query: ''
  })
}))

// Mock environment variables
process.env.NEXT_PUBLIC_APP_URL = 'http://localhost:3000'
```

## 🎯 Testing Best Practices

### **Test Organization:**
```typescript
describe('Component Name', () => {
  describe('when user is logged in', () => {
    it('shows user menu', () => {
      // Test implementation
    })

    it('allows profile editing', () => {
      // Test implementation
    })
  })

  describe('when user is not logged in', () => {
    it('shows login prompt', () => {
      // Test implementation
    })
  })
})
```

### **Arrange, Act, Assert Pattern:**
```typescript
it('updates user profile', async () => {
  // Arrange
  const user = createMockUser()
  render(<ProfileForm user={user} />)

  // Act
  const input = screen.getByLabelText('Name')
  fireEvent.change(input, { target: { value: 'New Name' } })

  const submitButton = screen.getByRole('button', { name: /save/i })
  fireEvent.click(submitButton)

  // Assert
  await waitFor(() => {
    expect(mockApi.put).toHaveBeenCalledWith('/api/user', {
      name: 'New Name'
    })
  })
})
```

### **Mocking Strategies:**
```typescript
// Mock API calls
jest.mock('@/lib/api', () => ({
  get: jest.fn(),
  post: jest.fn()
}))

// Mock custom hooks
jest.mock('@/hooks/useAuth', () => ({
  useAuth: () => ({
    user: createMockUser(),
    isAuthenticated: true
  })
}))

// Mock server responses
const mockServer = setupServer(
  rest.get('/api/user', (req, res, ctx) => {
    return res(ctx.json(createMockUser()))
  })
)
```

## 📊 Test Coverage

### **Coverage Goals:**
```json
{
  "coverageThreshold": {
    "global": {
      "branches": 80,
      "functions": 80,
      "lines": 80,
      "statements": 80
    }
  }
}
```

### **Coverage Categories:**
- **Statements**: Executed code lines
- **Branches**: Conditional paths (if/else, switch)
- **Functions**: Called functions
- **Lines**: Executed lines

### **Coverage Commands:**
```bash
# Run tests with coverage
npm run test:coverage

# Run specific test file
npm run test -- Component.test.tsx

# Watch mode for development
npm run test:watch
```

## 🚀 Testing Workflow

### **Development Testing:**
```bash
# Run all tests
npm test

# Run tests in watch mode
npm run test:watch

# Run tests for specific file
npm test -- Component.test.tsx

# Run tests with coverage
npm run test:coverage
```

### **CI/CD Testing:**
```bash
# Unit tests
npm run test:unit

# Integration tests
npm run test:integration

# E2E tests
npm run test:e2e

# Full test suite
npm run test:ci
```

## 🎯 Common Testing Scenarios

### **Form Testing:**
```typescript
it('validates form inputs', async () => {
  render(<ContactForm />)

  const submitButton = screen.getByRole('button', { name: /submit/i })
  fireEvent.click(submitButton)

  expect(await screen.findByText('Name is required')).toBeInTheDocument()
  expect(screen.getByText('Email is required')).toBeInTheDocument()
})
```

### **Async Testing:**
```typescript
it('loads data asynchronously', async () => {
  mockApi.get.mockResolvedValue({ data: mockProducts })

  render(<ProductList />)

  expect(screen.getByText('Loading...')).toBeInTheDocument()

  await waitFor(() => {
    expect(screen.getByText('Product 1')).toBeInTheDocument()
  })
})
```

### **Error Testing:**
```typescript
it('handles API errors gracefully', async () => {
  mockApi.get.mockRejectedValue(new Error('API Error'))

  render(<ProductList />)

  await waitFor(() => {
    expect(screen.getByText('Failed to load products')).toBeInTheDocument()
  })
})
```

## 🔧 Debugging Tests

### **Common Issues:**
```typescript
// Element not found
screen.debug() // Print current DOM

// Async timing issues
await waitFor(() => {}, { timeout: 5000 })

// Mock not working
jest.clearAllMocks()

// Test isolation
beforeEach(() => {
  jest.clearAllMocks()
})
```

### **Debugging Commands:**
```bash
# Run test with debug output
npm test -- --verbose

# Run single test with debugger
npm test -- --inspect-brk Component.test.tsx

# Check test coverage for specific file
npm run test:coverage -- --collectCoverageFrom="src/components/Component.tsx"
```